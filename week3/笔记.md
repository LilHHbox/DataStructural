



# 链表

## 1.ADT操作

指在程序中编写一次，而程序中任何其他部分需要再该ADT上运行的一种操作，都可以通过调用适当的函数进行，但对于程序的其余部分是完全透明的。



## 2.表ADT：

对表的所有操作都可以用数组来实现，但由于数组是动态指定的，但
要对表的最大值进行估计，但由于插入和删除的运行时间非常缓慢且表的大小已知，所以不用数组实现。
避免插入和删除的线性开销，避免连续存储，可使用链表。



## 3.链表的删除例程：

void Delete(ElementType x,List L)
{
  position P,TmpCell;
  p=FindPrevious(x,L);  //找到要删除元素的前驱
  if(!isLast(P,L))    //判断是不是最后一个元素
  {
   TmpCell=p->Next;    //把p的后继赋给TmpCell       （Next是指针而不是元素）
   P->Next=Tmpcell->Next;  //把TmpCell的后记赋给P的后继
   free(Tmpcell)   //删除TmpCell
  }       
}
    

## 4.常见的错误：

  (1):memory access violation或segmentation violation
      初始化变量失败；无论何时只要确定一个指向，那么就必须保证该指针不是NULL
  (2):涉及何时使用或何时不使用malloc来获取一个新的单元；必须记住：声明指向一个结构的指针并不创建该结构，而只是给出足够的空间容纳结构可能会使用的地址，创建尚未被声明过的记录的唯一方法是使用malloc库函数。另一方面，如果你想使用一个指针变量沿着一个表行进，那就没必要创建新的结构，此时不宜使用malloc命令。
      要求使用stdlib.h头文件
  (3):当有些空间不再需要时，可以使用free命令通知系统收回它。free(p)的结果是：P正在指向的地址没有变，但在该地址的处的数据此时已经无定义了。
  (4):如果从未对一个链表进行删除操作，那么调用malloc的次数应该等于表的大小，若有表头再+1。
  (5):删除链表时，对于要被释放的单元，要增加一个临时变量，因为再撤出指针的工作结束后，不能再引用它，详见课本图3-14，图3-15。

### 警告：malloc(sizeof(PtrTbnode))是合法的，但是它并不给结构体分配足够的空间。它只给指针分配空间。

## 5.双链表：

可以实现倒叙扫描。插入和删除的开销增加一倍，因为由于更多的指针需要定位，但简化了删除操作，因为不再被迫使用一个指向前驱元的指针来访问一个关键字。





# 栈

## 6.栈（后进先出表）

是限制插入和删除只能在一个位置上的表，对空栈进行的Pop和Top被认为是栈ADT的错误。



## 7.队列

入队，在表的末端插入一个元素；出队，在表的开头删除一个元素。



## 8.循环队列的实现

检测队列是否为空很重要，但判断是否为空有多种方法，Rear=Front-1是一种；在Enquene的次数肯定不会大于队列的大小的应用中，使用绕回是没有必要的。