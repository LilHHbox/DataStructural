1.算法：简单指令的集合

2.
定义:如果存在正常数c和n。使得当N≥n。时T(N)≤cf(N)，则记为T(N)=O( f(N))。
定义:如果存在正常数c和n。使得当N≥n。时·T(N)≥cg(N)，则记为T(N)=o g(N))。
定义:当且仅当T(N)=O(h(N))且 T(N)=Q(h(N))时，T(N)=6(h(N))。
定义:如果T(N)=O(p(N))且 T(N)≠O(p(N))，则T(N)=o(p(N))。
3.如果我们用传统的不等式来计算增长率，那么第一个定义是说T(N)的增长率小于等于(≤)f(N)的增长率。第二个定义T(N)=Q(g(N))(念成“omega”)是说T(N)的增长率大于等于(≥)g(N)的增长率。第三个定义T(N)=O(h(N))(念成“theta”)是说T(N)的增长率等于(=)h(N)的增长率。最后一个定义T(N)=o(p(N))(念成“小o……”)说的则是T(N)的增长率小于(≤<)p(N)的增长率。它不同于大O，因为大О包含增长率相同这种可能性。
定义:如果T(N)=O(p(N))且 T(N)≠O(p(N))，则T(N)=o(p(N))。
4.当我们说T(N)=O(f(N))时，是在保证函数T(N)以不快于f(N)的速度增长
因此f(N)是T(N)的上界(upper bound)。与此同时，f(N)=Q(T(N))意味着T(N)是f(N)的下界(lower bound)。
举例来说，N°增长得比N°快，因此我们可以说N'=O(N3)或NR=Q2(N')。f(N')=N'和 g(N)=2N°以相同的速率增长，从而f(N)=O(g(N))和f(N)=Q2(g(N))都是正确的。当两个函数以相同的速率增长时，是否需要使用记号“e()”表示可能依赖于具体的上下文。直观地说，如果g(N)=2N2，那么g(N)=O(N')、g(N)=O(N3)和 g(N)=O(N')从技术上看都是成立的，但最后一个选择是最好的答案。写法 g(N)=6(N2)不仅表示g(N)=O(N')而且还表示结果会尽可能好(严密)。
5.在需要大O表示的任何分析中，可以进行各种简化。低阶项一般可以被忽略，常熟也可以丢弃掉。
6.使用这种方法几乎总能算出相对增长率。通常，两个函数f(N)和 g(N)间的关系可以
用简单的代数方法得到。例如，如果f(N)=N log N且g(N)=N15，那么确定f(N)和g(N)哪个增长得更快，实际上就是确定log N和N“5哪个增长得更快。这与确定log'N和
N哪个增长得更快是一样的，而后者是个简单的问题，因为我们已经知道，N的增长要快于log N的任意次幂。因此，g(N)的增长快于f(N)的增长。
举例来说，N°增长得比N°快，因此我们可以说N'=O(N3)或NR=Q2(N')。f(N')=N'和 g(N)=2N°以相同的速率增长，从而f(N)=O(g(N))和f(N)=Q2(g(N))都是正确的。当两个函数以相同的速率增长时，是否需要使用记号“e()”表示可能依赖于具体的上下文。直观地说，如果g(N)=2N2，那么g(N)=O(N')、g(N)=O(N3)和 g(N)=O(N')从技术上看都是成立的，但最后一个选择是最好的答案。写法 g(N)=6(N2)不仅表示g(N)=O(N')而且还表示结果会尽可能好(严密)。
7.一般法则：
  (1)for循环：迭代次数乘每次运行时间
  (2)嵌套的for循环：从里向外每次循环的乘积
  (3)顺序语句：每条语句求和即可
  (4)if/else语句：判断时间加上S1，S2最长的时间
8.欧几里得算法
算法连续计算余数，直到余数是0为止，最后的非零余数就是最大公因数。
算法源于定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。