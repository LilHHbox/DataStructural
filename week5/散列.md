# 散列

#### 1.散列（以常数平均时间执行插入，删除和查找的技术）：

理想的散列表数据结构是以一个含有关键字的具有固定大小的数组，散列表的大小要保证是素数。

#### 2.分离链接法：

其做法是将散列到同一个值的所有元素保留在一个表中。

定义散列表的装填因子为散列表中的元素个数与散列表大小的比值，表达的大小实际上并不重要，装填因子才重要，如果装填因子过大，会容易产生冲突，就要调整散列表的长度。

#### 3.开放定址法：

发生冲突后尝试选择另外的单元，直到找出空的单元位置，用此方法的话装填因子应该小于0.5。

##### 线性探测法：

在先洗个探测法中，函数F是i的线性函数，典型情形是F(i)=i。这相当于逐个探测每个单元（必要时可以绕回）。

我们导出再一次不成功查找中探测的期望次数，而这正是知道我们找到一个空单元的探测期望次数。一次成功查找的探测次数等于该特定元素插入时所需要的探测次数。当一个元素被插入时，可以看成是一次不成功查找的结果。因此可以使用一次不成功查找的开销来计算一次成功查找的平均开销。

如果超过一半的表被填满的话，线性探测就不是一个好办法。

##### 平方探测法：

用来消除线性探测中一次聚集问题的冲突解决方法。

##### 双散列

##### 再散列：

当表到达某个装填因子时再进行散列(Rehash)，并消除原来的hash表。

#### 4.总结：

对于分离链接散列法，虽然装填因子不大时性能并不明显降低，但装填因子还是应该接近于1.对于开放定址散列算法，除非完全不可避免，否则装填因子不应该超过0.5。



# 堆



#### 1.斜堆：

具有堆序的二叉树，但关于任意节点的零路径长的任何信息都不保留。斜堆的右路径在任何时刻都可以任意长

#### 2.对于斜堆：

除了这些有路径上的所有节点的最大者不交换它们的左右儿子外，交换时无条件的。也可以非递归地进行所有的操作：合并右路径，除最后的节点外交换右路径上每个节点的做儿子和右儿子。

#### 3.斜堆的优点：

不需要附加的空间来保留路径长以及不需要测试确定何时交换儿子。

#### 4.二项队列：

每次操作的最坏情形运行时间为O(logN),而插入操作平均花费常数时间。

5.二项队列不是一棵堆序的树，而是堆序树的集合，称为森林。堆序树中的每一棵都是由约束的形式，叫做而橡树。每一个高度上至多存在一棵二项树。高度为0的二项树是一棵单节点树；高度为k的二项树Bk通过将一颗二项树Bk-1附接到另一棵二项树Bk-
的根上而构成	

6.如果元素将要插入的优先队列中不存在的最小二项树是Bi，那么运行时间与i+1成正比。